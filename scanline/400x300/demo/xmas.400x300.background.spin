'''' VGA scanline driver 400x300 - background renderer''''   Based on "Ball" demo for Gameduino''   Copyright (c) 2011 by James Bowman <jamesb@excamera.com>''''        Author: Marko Lukat'' Last modified: 2012/12/24''       Version: 0.9''OBJ  system: "core.con.system"  PUB null'' This is not a top level object.PUB init(ID, mailbox)  return system.launch(ID, @entry, mailbox)DAT             org     0                       ' background rendererentry           jmpret  $, #setup               ' once                                rdlong  indx, blnk              ' |                cmpsub  indx, scry wz           ' |        if_ne   jmp     #$-2                    ' waiting for last line to be fetched' Skip 26 sync lines and advance by a further 161 hub windows. This pushes the' first background renderer wrlong beyond the first video renderer line rdlong' if it were to render scanline -1.' After the waitcnt we have another 9 insn (36 + 18 + 10 = 64, 4 hub windows).                mov     cnt, cnt                add     cnt, $+1                long    13{18} + 10 + 132*16*26 + 16*(161 - 4)                loop            waitcnt cnt, one                ' initial sync point                call    #fill                   ' fill background                add     indx, #1                ' line done, advance                cmpsub  indx, scry wz           ' optionally wrap line index        if_z    add     cnt, twoone             long    132*16*2                ' skip two scan linestwo             long    132*16*28               ' skip all sync lines                jmp     #loop' support codefill            mov     addr, indx                shr     addr, #1 wc                add     read, addrfill_ret        long    0-0                     ' pipelineread            mov     addr, $+3        if_c    shr     addr, #16                jmpret  read, addr              ' render background                                word    eins[5],  zwei[3]                word    drei[21], zwei[3], drei[21], zwei[3], drei[21], zwei[3], drei[21], zwei[3]                word    drei[21], zwei[3], drei[21], zwei[3], drei[21], zwei[3], drei[21], zwei[3]                word    drei[21], zwei[3], drei[21], zwei[3], drei[21], zwei[3], drei[21], zwei[3]                word    eins[4]eins            mov     addr, base              ' A(99A)                wrlong  ty_A, addr                add     addr, #4                                mov     qcnt, #99:loop           wrlong  ty_A, addr                add     addr, #4                djnz    qcnt, #:loop                jmp     fill_retzwei            mov     addr, base              ' AB(48(CC))DA                wrlong  ty_A, addr                add     addr, #4                wrlong  ty_B, addr                add     addr, #4                mov     qcnt, #96/2:loop           wrlong  ty_C, addr                add     addr, #4                cmp     qcnt, #1 wz             ' last run?                wrlong  ty_C, addr                add     addr, #4        if_ne   djnz    qcnt, #:loop                wrlong  ty_D, addr                add     addr, #4                wrlong  ty_A, addr                jmp     fill_retdrei            mov     addr, base              ' AB(16(DAAAAB))DA                wrlong  ty_A, addr                add     addr, #4                wrlong  ty_B, addr                add     addr, #4                mov     qcnt, #16:loop           wrlong  ty_D, addr                add     addr, #4                cmp     qcnt, #1 wz             ' last run?                wrlong  ty_A, addr                add     addr, #4                wrlong  ty_A, addr                add     addr, #4                wrlong  ty_A, addr                add     addr, #4                wrlong  ty_A, addr                add     addr, #4                wrlong  ty_B, addr                add     addr, #4        if_ne   djnz    qcnt, #:loop                wrlong  ty_D, addr                add     addr, #4                wrlong  ty_A, addr                                jmp     fill_ret' initialised data and/or presetsblnk            long    -4base            long    NEGXty_A    {----}  long    $01010101 * C0ty_B    {---#}  long    $00010101 * C0 + $01000000 * C1ty_C    {####}  long                     $01010101 * C1ty_D    {##--}  long    $01010000 * C0 + $00000101 * C1' Stuff below is re-purposed for temporary storage.setup           add     base, par               ' scanline buffer       (%%)                add     blnk, base wc           ' frame indicator                rdword  indx, blnk wz           '                       (%%)        if_nz   mov     scry, indx wc           '                       (%%)   if_c_or_nz   jmp     #$-2                    ' auto-detect res_y' The loop is only left once a non-zero value has been written to scry' and indx transitions to zero afterwards.                jmp     %%0                     ' return                fit                ' uninitialised data and/or temporaries                org     setupscry            res     1                       ' must be 1st/2nd       (%%)indx            res     1                       ' |addr            res     1qcnt            res     1tail            fitCON  C0   = %%2220                                 ' background  C1   = %%1110                                 ' gridDAT{{ TERMS OF USE: MIT License Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}DAT